import jsPDF from 'jspdf';
import { BookData } from './bookTypes';
import { registerPlayfairFont } from './pdfFonts';

interface GeneratePDFOptions {
  topic: string;
  bookData: BookData;
  coverImageUrl?: string;
  isKdpManuscript?: boolean;
  returnBlob?: boolean;
  includeCoverPage?: boolean;
}

// Helper: Draw a vector "Key" icon for Pro-Tips (Manual Vector Path)
const drawKeyIcon = (doc: jsPDF, x: number, y: number, size: number = 0.2) => {
  doc.setDrawColor(0, 0, 0); // Black
  doc.setLineWidth(0.015);
  
  // Key Head (Circle)
  doc.circle(x + size/2, y + size/2, size/3);
  
  // Key Shaft (Line) at 45 degrees
  const angle = Math.PI / 4;
  const r = size/3;
  const cx = x + size/2;
  const cy = y + size/2;
  
  const shaftStartX = cx + (r * Math.cos(angle));
  const shaftStartY = cy + (r * Math.sin(angle));
  const shaftEndX = x + size;
  const shaftEndY = y + size;
  
  doc.line(shaftStartX, shaftStartY, shaftEndX, shaftEndY);
  
  // Key Teeth
  const toothLen = size * 0.15;
  doc.line(shaftEndX, shaftEndY, shaftEndX, shaftEndY + toothLen);
  const midX = shaftEndX - (size * 0.15);
  const midY = shaftEndY - (size * 0.15);
  doc.line(midX, midY, midX, midY + toothLen);
};

// Helper: Robust Image Loader (Fetches Blob to avoid CORS/Taint issues)
const loadImage = async (url: string): Promise<string | null> => {
  try {
    const response = await fetch(url, { mode: 'cors' });
    if (!response.ok) return null;
    const blob = await response.blob();
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result as string);
      reader.onerror = () => resolve(null);
      reader.readAsDataURL(blob);
    });
  } catch (error) {
    console.warn("Failed to load PDF image:", url);
    return null;
  }
};

export const generateCleanPDF = async ({ 
  topic, 
  bookData, 
  coverImageUrl, 
  isKdpManuscript = false,
  returnBlob = false,
  includeCoverPage = false
}: GeneratePDFOptions): Promise<Blob | void> => {
  
  // 1. Setup Standard KDP 6x9 Format
  const format = isKdpManuscript ? [6, 9] : 'letter';
  const doc = new jsPDF({ orientation: 'portrait', unit: 'in', format });
  
  // Register Playfair Display
  await registerPlayfairFont(doc);

  const title = bookData.displayTitle || topic;
  const pageWidth = isKdpManuscript ? 6 : 8.5;
  const pageHeight = isKdpManuscript ? 9 : 11;
  const margin = 0.75; 
  const writableWidth = pageWidth - (margin * 2);

  // Helper: Pagination Control
  let yPos = margin;
  
  const checkPageBreak = (heightNeeded: number) => {
    // Leave a 0.5" buffer at bottom
    if (yPos + heightNeeded > pageHeight - 0.5) {
      doc.addPage();
      yPos = margin;
      return true;
    }
    return false;
  };

  // --- 1. TITLE PAGE ---
  doc.setFont('PlayfairDisplay', 'bold');
  doc.setFontSize(24);
  doc.setTextColor(0, 0, 0);
  
  yPos = pageHeight * 0.35;
  
  const splitTitle = doc.splitTextToSize(title.toUpperCase(), writableWidth);
  doc.text(splitTitle, pageWidth / 2, yPos, { align: 'center' });
  
  yPos += (splitTitle.length * 0.4) + 0.2;
  if (bookData.subtitle) {
    doc.setFont('PlayfairDisplay', 'italic');
    doc.setFontSize(14);
    doc.setTextColor(80, 80, 80);
    doc.text(doc.splitTextToSize(bookData.subtitle, writableWidth), pageWidth / 2, yPos, { align: 'center' });
  }

  // Branding
  doc.setFontSize(10);
  doc.setFont('PlayfairDisplay', 'normal');
  doc.setTextColor(150, 150, 150);
  doc.text("LOOM & PAGE", pageWidth / 2, pageHeight - margin, { align: 'center' });

  // --- 2. COPYRIGHT PAGE ---
  doc.addPage();
  doc.setFont('PlayfairDisplay', 'normal');
  doc.setFontSize(9);
  doc.setTextColor(0, 0, 0);

  const copyrightText = `Copyright Â© ${new Date().getFullYear()}

All rights reserved.

Published by Loom & Page
www.LoomandPage.com

No part of this publication may be reproduced, distributed, or transmitted in any form or by any means, including photocopying, recording, or other electronic or mechanical methods, without the prior written permission of the publisher.

Book generated by Loom & Page AI Engine.

First Edition: ${new Date().toLocaleString('default', { month: 'long' })} ${new Date().getFullYear()}`;

  const splitCopyright = doc.splitTextToSize(copyrightText.trim(), writableWidth);
  const copyrightHeight = splitCopyright.length * 0.15;
  doc.text(splitCopyright, margin, pageHeight - margin - copyrightHeight);

  // --- 3. TABLE OF CONTENTS ---
  doc.addPage();
  yPos = margin + 0.5;
  
  doc.setFont('PlayfairDisplay', 'bold');
  doc.setFontSize(16);
  doc.text("Table of Contents", pageWidth / 2, yPos, { align: 'center' });
  
  yPos += 0.5;
  doc.setFont('PlayfairDisplay', 'normal');
  doc.setFontSize(11);
  
  const chapters = bookData.tableOfContents || [];
  chapters.forEach((ch: any) => {
    checkPageBreak(0.35);
    doc.text(`Chapter ${ch.chapter}: ${ch.title}`, margin, yPos);
    yPos += 0.35;
  });

  // --- 4. CHAPTER CONTENT LOOP ---
  // Sort by chapter number
  const chapterKeys = Object.keys(bookData).filter(k => k.startsWith('chapter') && k.endsWith('Content'));
  // Use tableOfContents if available, otherwise fallback to keys
  const loopSource = chapters.length > 0 ? chapters : chapterKeys.map((k, i) => ({ chapter: i + 1, title: `Chapter ${i + 1}` }));

  for (const ch of loopSource) {
    const chapterNum = ch.chapter;
    const contentKey = `chapter${chapterNum}Content` as keyof BookData;
    const rawContent = (bookData[contentKey] as string) || "";
    
    if (!rawContent) continue;

    // Start Chapter on NEW PAGE
    doc.addPage();
    yPos = margin + 0.5;

    // Chapter Header
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.setFont('PlayfairDisplay', 'normal');
    doc.text(`CHAPTER ${chapterNum}`, pageWidth / 2, yPos, { align: 'center', charSpace: 0.1 });
    
    yPos += 0.4;
    
    doc.setFont('PlayfairDisplay', 'bold');
    doc.setFontSize(20);
    doc.setTextColor(0, 0, 0);
    const chapterTitleLines = doc.splitTextToSize(ch.title, writableWidth);
    doc.text(chapterTitleLines, pageWidth / 2, yPos, { align: 'center' });
    
    yPos += (chapterTitleLines.length * 0.35) + 0.3;

    // Divider
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.01);
    const lineW = 0.5;
    doc.line((pageWidth - lineW)/2, yPos, (pageWidth + lineW)/2, yPos);
    
    yPos += 0.5;

    // Content Processing
    const lines = rawContent.replace(/\r\n/g, '\n').split('\n');
    doc.setFont('PlayfairDisplay', 'normal');
    doc.setFontSize(11);

    for (let i = 0; i < lines.length; i++) {
      let line = lines[i].trim();
      if (!line) {
        yPos += 0.15; // Paragraph spacing
        continue;
      }

      // --- A. IMAGES ---
      const imgMatch = line.match(/!\[.*?\]\((.*?)\)/);
      if (imgMatch && imgMatch[1]) {
        const imgUrl = imgMatch[1];
        const imgSpace = 4.5; 
        
        checkPageBreak(imgSpace);
        
        // Load image base64
        const imgBase64 = await loadImage(imgUrl);
        if (imgBase64) {
          try {
            const w = Math.min(writableWidth, 4.5);
            const h = w * 0.66; // approx landscape aspect
            
            if (yPos + h > pageHeight - margin) {
              doc.addPage();
              yPos = margin;
            }
            const imgX = (pageWidth - w) / 2;
            doc.addImage(imgBase64, 'JPEG', imgX, yPos, w, h);
            yPos += h + 0.3; 
          } catch (e) {
            console.warn("Error drawing image to PDF", e);
          }
        }
        continue;
      }

      // --- B. HEADERS (Orphan Control) ---
      if (line.startsWith('#')) {
        const level = line.match(/^#+/)?.[0].length || 1;
        const text = line.replace(/^#+\s*/, '').replace(/\*\*/g, '');
        
        // Orphan Logic: Ensure Header + 3 lines of text fit
        const requiredSpace = 0.5 + (0.2 * 3); 
        checkPageBreak(requiredSpace);

        doc.setFont('PlayfairDisplay', 'bold');
        const fontSize = level === 1 ? 16 : level === 2 ? 14 : 12;
        doc.setFontSize(fontSize);
        doc.setTextColor(0, 0, 0);
        
        yPos += 0.3; 
        const split = doc.splitTextToSize(text, writableWidth);
        doc.text(split, margin, yPos);
        yPos += (split.length * (fontSize/72) * 1.5) + 0.1;
        
        doc.setFont('PlayfairDisplay', 'normal');
        doc.setFontSize(11);
        continue;
      }

      // --- C. PRO-TIPS (Onyx Style Box + Key Icon) ---
      if (line.startsWith('>')) {
        // Collect multi-line blockquotes
        let proTipContent = line.replace(/^>\s*/, '');
        let lookAheadIndex = i + 1;
        while(lookAheadIndex < lines.length && lines[lookAheadIndex].trim().startsWith('>')) {
          proTipContent += ' ' + lines[lookAheadIndex].trim().replace(/^>\s*/, '');
          i++; 
          lookAheadIndex++;
        }

        const text = proTipContent.replace(/\*\*/g, '').replace(/PRO[- ]?TIP:?/i, '').trim();
        
        const boxPadding = 0.2;
        const indent = boxPadding + 0.1; 
        const textWidth = writableWidth - indent;
        
        doc.setFont('PlayfairDisplay', 'italic');
        doc.setFontSize(10.5);
        const split = doc.splitTextToSize(text, textWidth);
        
        const headerHeight = 0.35; 
        const contentHeight = split.length * 0.2; 
        const totalBoxHeight = headerHeight + contentHeight + (boxPadding * 2);

        checkPageBreak(totalBoxHeight + 0.2);

        // 1. Draw "Onyx" Left Border
        doc.setDrawColor(0, 0, 0);
        doc.setLineWidth(0.03); 
        doc.line(margin, yPos, margin, yPos + totalBoxHeight);

        // 2. Draw Vector "Key" Icon
        drawKeyIcon(doc, margin + 0.1, yPos + boxPadding, 0.15);

        // 3. "PRO TIP" Label
        doc.setFont('PlayfairDisplay', 'bold');
        doc.setFontSize(9);
        doc.setTextColor(0, 0, 0);
        doc.text("PRO TIP", margin + 0.35, yPos + boxPadding + 0.12);

        // 4. Content Text
        doc.setFont('PlayfairDisplay', 'italic');
        doc.setFontSize(10.5);
        doc.setTextColor(60, 60, 60); 
        doc.text(split, margin + 0.35, yPos + boxPadding + headerHeight);

        yPos += totalBoxHeight + 0.3; 
        
        doc.setTextColor(0, 0, 0);
        doc.setFont('PlayfairDisplay', 'normal');
        doc.setFontSize(11);
        continue;
      }

      // --- D. BULLET POINTS ---
      if (line.trim().startsWith('- ') || line.trim().startsWith('* ')) {
        const cleanLine = line.replace(/^[-*]\s*/, '').replace(/\*\*/g, '');
        const bulletIndent = 0.25;
        
        const splitText = doc.splitTextToSize(cleanLine, writableWidth - bulletIndent);
        checkPageBreak(splitText.length * 0.2);

        // Draw Bullet Circle
        doc.setDrawColor(0,0,0);
        doc.setFillColor(0,0,0);
        doc.circle(margin + 0.1, yPos - 0.04, 0.02, 'F');
        
        // Draw Text
        doc.text(splitText, margin + bulletIndent, yPos);
        
        yPos += (splitText.length * 0.2) + 0.05;
        continue;
      }

      // --- E. STANDARD PARAGRAPH ---
      const cleanLine = line.replace(/\*\*/g, '').replace(/\*/g, ''); 
      const splitText = doc.splitTextToSize(cleanLine, writableWidth);
      
      // Widow/Orphan check
      if (yPos + (splitText.length * 0.2) > pageHeight - 0.5) {
        if (splitText.length < 4) {
           doc.addPage();
           yPos = margin;
        }
      }
      
      checkPageBreak(0.2); 
      
      doc.text(splitText, margin, yPos);
      yPos += (splitText.length * 0.2);
    }
  }

  if (returnBlob) return doc.output('blob');
  doc.save(`${title.replace(/[^a-z0-9]/gi, '_')}.pdf`);
};
